"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createKey: function() {\n        return createKey;\n    },\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"./node_modules/next/dist/client/resolve-href.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    let rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    const matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || false) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then((param)=>{\n                let [pages, { __rewrites: rewrites }] = param;\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        });\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    const redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            });\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname + src.query + src.hash,\n                newUrl: \"\" + pathname + src.query + src.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    const data = await options.fetchData();\n    const effect = await getMiddlewareData(data.dataHref, data.response, options);\n    return {\n        dataHref: data.dataHref,\n        json: data.json,\n        response: data.response,\n        text: data.text,\n        cacheKey: data.cacheKey,\n        effect\n    };\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    const getData = (params)=>{\n        var _params_method;\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then((response)=>{\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref,\n                    response,\n                    text: \"\",\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            if (data.response.headers.get(\"x-middleware-cache\") !== \"no-cache\") {\n                // only update cache if not marked as no-cache\n                inflightCache[cacheKey] = Promise.resolve(data);\n            }\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    let { url, router } = param;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = (param)=>{\n    let { route, router } = param;\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options) {\n        if (options === void 0) options = {};\n        if (false) {}\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"pushState\", url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options) {\n        if (options === void 0) options = {};\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change(\"replaceState\", url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (true) {\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            for (const curAs of [\n                as,\n                resolvedAs\n            ]){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, \"http://n\").pathname)) {\n                        var _this__bfl_s, _this__bfl_s1;\n                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split(\"/\");\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                var _this__bfl_d;\n                                const currentPart = curAsParts.slice(0, i).join(\"/\");\n                                if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        var _this_components_pathname;\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (false) { var _this_locales; }\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark(\"routeChange\");\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit(\"routeChangeError\", buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit(\"hashChangeStart\", as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit(\"hashChangeComplete\", as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = \"replaceState\";\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== \"/_error\") {\n            options._shouldResolveHref = true;\n            if (false) {} else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (true) {\n                throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (true) {\n                        console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                    }\n                    throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit(\"routeChangeStart\", as, routeProps);\n        }\n        const isErrorRoute = this.pathname === \"/404\" || this.pathname === \"/_error\";\n        try {\n            var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if (\"route\" in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (false) {}\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if (\"type\" in routeInfo) {\n                if (routeInfo.type === \"redirect-internal\") {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent(\"/404\");\n                        notFoundRoute = \"/404\";\n                    } catch (_) {\n                        notFoundRoute = \"/_error\";\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if (\"type\" in routeInfo) {\n                        throw new Error(\"Unexpected middleware effect on /404\");\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            var _routeInfo_route;\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n            var _options_scroll;\n            const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if (\"type\" in routeInfo) {\n                    throw new Error(\"Unexpected middleware effect on \" + this.pathname);\n                }\n                if (this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (false) {}\n                if (!isQueryUpdating) {\n                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options) {\n        if (options === void 0) options = {};\n        if (true) {\n            if (typeof window.history === \"undefined\") {\n                console.error(\"Warning: window.history is not available.\");\n                return;\n            }\n            if (typeof window.history[method] === \"undefined\") {\n                console.error(\"Warning: window.history.\" + method + \" is not available\");\n                return;\n            }\n        }\n        if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== \"pushState\" ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            \"\", as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        console.error(err);\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit(\"routeChangeError\", err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent(\"/_error\");\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo(param) {\n        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            var _data_effect, _data_effect1, _data_effect2, _data_response;\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? \"/404\" : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? \"/404\" : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                return data.effect;\n            }\n            if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\") {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (true) {\n                const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                }\n            }\n            const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split(\"#\", 2);\n        const [newUrlNoHash, newHash] = as.split(\"#\", 2);\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = \"\"] = as.split(\"#\", 2);\n        (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === \"\" || hash === \"top\") {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath, options) {\n        if (asPath === void 0) asPath = url;\n        if (options === void 0) options = {};\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (true) {\n            return;\n        }\n        if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (false) {}\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (false) {}\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data =  false ? 0 : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = new Error(\"Loading initial props cancelled\");\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    _getFlightData(dataHref) {\n        // Do not cache RSC flight response since it's not a static resource\n        return fetchNextData({\n            dataHref,\n            isServerRender: true,\n            parseJSON: false,\n            inflightCache: this.sdc,\n            persistCache: false,\n            isPrefetch: false\n        }).then((param)=>{\n            let { text } = param;\n            return {\n                data: text\n            };\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components[\"/_app\"];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            const { BloomFilter } = __webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\");\n            const routerFilterSValue = {\"numItems\":5,\"errorRate\":0.0001,\"numBits\":96,\"numHashes\":14,\"bitArray\":[1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,1,1,0,0,1,0,0,1,1]};\n            const staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n            const routerFilterDValue = {\"numItems\":2,\"errorRate\":0.0001,\"numBits\":39,\"numHashes\":14,\"bitArray\":[0,1,1,0,1,1,0,1,1,1,0,0,1,1,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,0,0,1,1,0,0]};\n            const dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s.import(staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d.import(dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n}\nRouter.events = (0, _mitt.default)(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFDZjtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUlOO0FBQ0EsU0FBU0ksUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVYsT0FBT0MsY0FBYyxDQUFDUSxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFOLFNBQVM7SUFDYkcsV0FBVztRQUNQLE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9RO0lBQ1g7SUFDQVAsbUJBQW1CO1FBQ2YsT0FBT0E7SUFDWDtBQUNKO0FBQ0EsTUFBTVEsMkJBQTJCQyxtQkFBT0EsQ0FBQyw0R0FBeUM7QUFDbEYsTUFBTUMsNEJBQTRCRCxtQkFBT0EsQ0FBQyw4R0FBMEM7QUFDcEYsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnSEFBK0I7QUFDcEUsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMscUZBQThCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLHlFQUF3QjtBQUNoRCxNQUFNSyxXQUFXLFdBQVcsR0FBR0osMEJBQTBCSyxDQUFDLENBQUNOLG1CQUFPQSxDQUFDLHVFQUF1QjtBQUMxRixNQUFNTyx1QkFBdUJQLG1CQUFPQSxDQUFDLGtIQUFvQztBQUN6RSxNQUFNUSx1QkFBdUJSLG1CQUFPQSxDQUFDLHdHQUErQjtBQUNwRSxNQUFNUyxRQUFRLFdBQVcsR0FBR1YseUJBQXlCTyxDQUFDLENBQUNOLG1CQUFPQSxDQUFDLDREQUFTO0FBQ3hFLE1BQU1VLFNBQVNWLG1CQUFPQSxDQUFDLDhEQUFVO0FBQ2pDLE1BQU1XLGFBQWFYLG1CQUFPQSxDQUFDLDBGQUFvQjtBQUMvQyxNQUFNWSxvQkFB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YXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY3JlYXRlS2V5OiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgY3JlYXRlS2V5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUtleTtcbiAgICB9LFxuICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUm91dGVyO1xuICAgIH0sXG4gICAgbWF0Y2hlc01pZGRsZXdhcmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc01pZGRsZXdhcmU7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pc2FwaXJvdXRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfY29tcGFyZXN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfaXNib3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XG5jb25zdCBfb21pdCA9IHJlcXVpcmUoXCIuL3V0aWxzL29taXRcIik7XG5jb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoXCJSb3V0ZSBDYW5jZWxsZWRcIiksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcbiAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICBjb25zdCBhc1dhc0Fic29sdXRlID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZldhc0Fic29sdXRlID8gcmVzb2x2ZWRIcmVmIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbigoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwcmVwYXJlZEFzKVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9kZW5vcm1hbGl6ZXBhZ2VwYXRoLmRlbm9ybWFsaXplUGFnZVBhdGgpKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IGNsZWFuUGF0aG5hbWUgPT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYWdlKSAmJiAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICB9LFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcbiAgICB9O1xuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJld3JpdGVcIik7XG4gICAgbGV0IHJld3JpdGVUYXJnZXQgPSByZXdyaXRlSGVhZGVyIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1hdGNoZWQtcGF0aFwiKTtcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiX19uZXh0X2RhdGFfY2F0Y2hhbGxcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiL19lcnJvclwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvNDA0XCIpKSB7XG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgICAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGg7XG4gICAgfVxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXdyaXRlVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9ICgwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZzUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWVJbmZvLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKVxuICAgICAgICAgICAgXSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9XSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTID8gdW5kZWZpbmVkIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRTb3VyY2UucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKGFzLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIChwYXRoKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lLCBwYWdlcykgOiBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocmVzb2x2ZWRIcmVmKSkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJld3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZWRpcmVjdFwiKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWludGVybmFsXCIsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogXCJuZXh0XCJcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpO1xuICAgIGNvbnN0IGVmZmVjdCA9IGF3YWl0IGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgICAgIHJlc3BvbnNlOiBkYXRhLnJlc3BvbnNlLFxuICAgICAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICBlZmZlY3RcbiAgICB9O1xufVxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgXCJzY3JvbGxSZXN0b3JhdGlvblwiIGluIHdpbmRvdy5oaXN0b3J5ICYmICEhZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHYgPSBcIl9fbmV4dFwiO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VxdWVuY2VzXG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHYsIHYpLCBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKHYpLCB0cnVlO1xuICAgIH0gY2F0Y2ggKG4pIHt9XG59KCk7XG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woXCJTU0dfREFUQV9OT1RfRk9VTkRcIik7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIG1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIixcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgICBcIngtbmV4dGpzLWRhdGFcIjogXCIxXCJcbiAgICAgICAgfSlcbiAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMCA/IGZldGNoUmV0cnkodXJsLCBhdHRlbXB0cyAtIDEsIG9wdGlvbnMpIDogcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHBhcmFtKSB7XG4gICAgbGV0IHsgZGF0YUhyZWYsIGluZmxpZ2h0Q2FjaGUsIGlzUHJlZmV0Y2gsIGhhc01pZGRsZXdhcmUsIGlzU2VydmVyUmVuZGVyLCBwYXJzZUpTT04sIHBlcnNpc3RDYWNoZSwgaXNCYWNrZ3JvdW5kLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaHJlZjogY2FjaGVLZXkgfSA9IG5ldyBVUkwoZGF0YUhyZWYsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBnZXREYXRhID0gKHBhcmFtcyk9PntcbiAgICAgICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiBcInByZWZldGNoXCJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xuICAgICAgICAgICAgICAgIFwieC1taWRkbGV3YXJlLXByZWZldGNoXCI6IFwiMVwiXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtY2FjaGVcIikgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gY2hyb21lXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gd2hlbiBza2lwcGluZyBjbGllbnQgY2FjaGUgd2Ugd2FpdCB0byB1cGRhdGVcbiAgICAvLyBpbmZsaWdodCBjYWNoZSB1bnRpbCBzdWNjZXNzZnVsIGRhdGEgcmVzcG9uc2VcbiAgICAvLyB0aGlzIGFsbG93cyByYWNpbmcgY2xpY2sgZXZlbnQgd2l0aCBmZXRjaGluZyBuZXdlciBkYXRhXG4gICAgLy8gd2l0aG91dCBibG9ja2luZyBuYXZpZ2F0aW9uIHdoZW4gc3RhbGUgZGF0YSBpcyBhdmFpbGFibGVcbiAgICBpZiAodW5zdGFibGVfc2tpcENsaWVudENhY2hlICYmIHBlcnNpc3RDYWNoZSkge1xuICAgICAgICByZXR1cm4gZ2V0RGF0YSh7fSkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLWNhY2hlXCIpICE9PSBcIm5vLWNhY2hlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHVwZGF0ZSBjYWNoZSBpZiBub3QgbWFya2VkIGFzIG5vLWNhY2hlXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZ2V0RGF0YShpc0JhY2tncm91bmQgPyB7XG4gICAgICAgIG1ldGhvZDogXCJIRUFEXCJcbiAgICB9IDoge30pO1xufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMCk7XG59XG5mdW5jdGlvbiBoYW5kbGVIYXJkTmF2aWdhdGlvbihwYXJhbSkge1xuICAgIGxldCB7IHVybCwgcm91dGVyIH0gPSBwYXJhbTtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gaGFyZCBuYXZpZ2F0ZSB0byB0aGUgc2FtZSBVUkwgXCIgKyB1cmwgKyBcIiBcIiArIGxvY2F0aW9uLmhyZWYpO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAocGFyYW0pPT57XG4gICAgbGV0IHsgcm91dGUsIHJvdXRlciB9ID0gcGFyYW07XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhbmNlbCA9IHJvdXRlci5jbGMgPSAoKT0+e1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gKCk9PntcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0Fib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJyArIHJvdXRlICsgJ1wiJyk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFwicHVzaFN0YXRlXCIsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICogUGVyZm9ybXMgYSBgcmVwbGFjZVN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovIHJlcGxhY2UodXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgICh7IHVybCwgYXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgX2JmbChhcywgcmVzb2x2ZWRBcywgbG9jYWxlLCBza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG1hdGNoZXNCZmxEeW5hbWljID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN1ckFzIG9mIFtcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzXG4gICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb1NsYXNoID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwoY3VyQXMsIFwiaHR0cDovL25cIikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc05vU2xhc2ggIT09ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShuZXcgVVJMKHRoaXMuYXNQYXRoLCBcImh0dHA6Ly9uXCIpLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfcywgX3RoaXNfX2JmbF9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChfdGhpc19fYmZsX3MgPSB0aGlzLl9iZmxfcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfcy5jb250YWlucyhhc05vU2xhc2gpKSB8fCAhISgoX3RoaXNfX2JmbF9zMSA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zMS5jb250YWlucyhhc05vU2xhc2hMb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9ybWFsaXplZEFTIG9mIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNOb1NsYXNoTG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBzaG91bGQgYmUgaGFyZCBuYXZpZ2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJBc1BhcnRzID0gbm9ybWFsaXplZEFTLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19iZmxfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChfdGhpc19fYmZsX2QgPSB0aGlzLl9iZmxfZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX19iZmxfZC5jb250YWlucyhjdXJyZW50UGFydCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGllbnQgcm91dGVyIGZpbHRlciBpcyBtYXRjaGVkIHRoZW4gd2UgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXMsIGxvY2FsZSB8fCB0aGlzLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgY2hhbmdlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucywgZm9yY2VkU2Nyb2xsKSB7XG4gICAgICAgIHZhciBfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lO1xuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKSh1cmwpKSB7XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiAhb3B0aW9ucy5zaGFsbG93KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIHVuZGVmaW5lZCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkoYXMpLnBhdGhuYW1lO1xuICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlXG4gICAgICAgIH07XG4gICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAgICAgLy8gb3IgYSBuYXZpZ2F0aW9uIGhhcyBvY2N1cnJlZFxuICAgICAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gdGhpcy5pc1JlYWR5ICE9PSB0cnVlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3I7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3NyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYSByb3V0ZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MgYmVmb3JlXG4gICAgICAgIC8vIHRoZSBxdWVyeSB1cGRhdGluZyBpcyB0cmlnZ2VyZWQgaWdub3JlIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2TG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyB0aGlzLmRlZmF1bHRMb2NhbGUgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvY2FsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlO1xuICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkodXJsKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHVybCkgOiB1cmwsIHRoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZE5hdmlnYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfbG9jYWxlcztcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgICAgICAgICAgaWYgKCEoKF90aGlzX2xvY2FsZXMgPSB0aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19sb2NhbGVzLmluY2x1ZGVzKG5leHRTdGF0ZS5sb2NhbGUpKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWRBcyksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9ICgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkodGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5hdmlnYXRpbmcgdG8gYSBkb21haW4gbG9jYWxlIGVuc3VyZSB3ZSByZWRpcmVjdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGRvbWFpblxuICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgdGhpcy5pc0xvY2FsZURvbWFpbiAmJiBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IFwiaHR0cFwiICsgKGRldGVjdGVkRG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIiArIGRldGVjdGVkRG9tYWluLmRvbWFpbiArICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKFwiXCIgKyAobmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIG5leHRTdGF0ZS5sb2NhbGUpICsgKGFzTm9CYXNlUGF0aCA9PT0gXCIvXCIgPyBcIlwiIDogYXNOb0Jhc2VQYXRoKSB8fCBcIi9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICAgIGlmIChfdXRpbHMuU1QpIHtcbiAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoXCJyb3V0ZUNoYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHNoYWxsb3cgPSBmYWxzZSwgc2Nyb2xsID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm91dGVQcm9wcyA9IHtcbiAgICAgICAgICAgIHNoYWxsb3dcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX2luRmxpZ2h0Um91dGUgJiYgdGhpcy5jbGMpIHtcbiAgICAgICAgICAgIGlmICghaXNTc3IpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgdGhpcy5faW5GbGlnaHRSb3V0ZSwgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsYygpO1xuICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFzID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhcykgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcykgOiBhcywgb3B0aW9ucy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGNsZWFuZWRBcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KG5leHRTdGF0ZSwgdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNlcnJvci5kZWZhdWx0KShlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImhhc2hDaGFuZ2VDb21wbGV0ZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkO1xuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcInJlcGxhY2VTdGF0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aChcIi9cIikgJiYgKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgLy8gaWYgd2UgZGV0ZWN0ZWQgdGhlIHBhdGggYXMgYXBwIHJvdXRlIGR1cmluZyBwcmVmZXRjaGluZ1xuICAgICAgICAvLyB0cmlnZ2VyIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICBpZiAoKF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUgPSB0aGlzLmNvbXBvbmVudHNbcGF0aG5hbWVdKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfY29tcG9uZW50c19wYXRobmFtZS5fX2FwcFJvdXRlcikge1xuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShwYXJzZWRBc1BhdGhuYW1lICYmIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmICghKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSB8fCAhKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSkpO1xuICAgICAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgICAgIC8vIG1pZGRsZXdhcmUgYXMgdGhlIHJlc29sdmluZyB3aWxsIG9jY3VyIHNlcnZlci1zaWRlXG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gIW9wdGlvbnMuc2hhbGxvdyAmJiBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGNsZWFuZWRBcywgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZSAhPT0gcGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoMCwgX2lzbG9jYWx1cmwuaXNMb2NhbFVSTCkoYXMpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhyZWY6IFwiJyArIHVybCArICdcIiBhbmQgYXM6IFwiJyArIGFzICsgJ1wiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhcycgKyBcIlxcblNlZSBtb3JlIGluZm86IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2ludmFsaWQtcmVsYXRpdmUtdXJsLWV4dGVybmFsLWFzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXNvbHZlZEFzKSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgIHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgbGV0IHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHJlc29sdmVkQXMpO1xuICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSk7XG4gICAgICAgICAgICByb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRBcyA9IHNob3VsZEludGVycG9sYXRlID8gKDAsIF9pbnRlcnBvbGF0ZWFzLmludGVycG9sYXRlQXMpKHJvdXRlLCBhc1BhdGhuYW1lLCBxdWVyeSkgOiB7fTtcbiAgICAgICAgICAgIGlmICghcm91dGVNYXRjaCB8fCBzaG91bGRJbnRlcnBvbGF0ZSAmJiAhaW50ZXJwb2xhdGVkQXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsKTtcbiAgICAgICAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJcIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiSW50ZXJwb2xhdGluZyBocmVmXCIgOiBcIk1pc21hdGNoaW5nIGBhc2AgYW5kIGBocmVmYFwiKSArIFwiIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIFwiICsgKFwidGhlIHBhcmFtczogXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiIGluIHRoZSBgaHJlZmAncyBgcXVlcnlgXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gXCJUaGUgcHJvdmlkZWQgYGhyZWZgIChcIiArIHVybCArIFwiKSB2YWx1ZSBpcyBtaXNzaW5nIHF1ZXJ5IHZhbHVlcyAoXCIgKyBtaXNzaW5nUGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIFwiIDogXCJUaGUgcHJvdmlkZWQgYGFzYCB2YWx1ZSAoXCIgKyBhc1BhdGhuYW1lICsgXCIpIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBgaHJlZmAgdmFsdWUgKFwiICsgcm91dGUgKyBcIikuIFwiKSArIChcIlJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvXCIgKyAoc2hvdWxkSW50ZXJwb2xhdGUgPyBcImhyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWRcIiA6IFwiaW5jb21wYXRpYmxlLWhyZWYtYXNcIikpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkQXMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdC5vbWl0KShxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VTdGFydFwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNFcnJvclJvdXRlID0gdGhpcy5wYXRobmFtZSA9PT0gXCIvNDA0XCIgfHwgdGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMsIF9yb3V0ZUluZm9fcHJvcHM7XG4gICAgICAgICAgICBsZXQgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9iZmwoYXMsIFwicmVzb2x2ZWRBc1wiIGluIHJvdXRlSW5mbyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogdW5kZWZpbmVkLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChcInJvdXRlXCIgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByb3V0ZUluZm8ucm91dGUgfHwgcm91dGU7XG4gICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHJvdXRlSW5mby5xdWVyeSB8fCB7fSwgcXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhbmVkUGFyc2VkUGF0aG5hbWUgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkLnBhdGhuYW1lKSA6IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBwYXRobmFtZSAhPT0gY2xlYW5lZFBhcnNlZFBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBxdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9ICFyb3V0ZVByb3BzLnNoYWxsb3cgJiYgcm91dGVJbmZvLnJlc29sdmVkQXMgPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkobmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXM7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlQXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gbG9jYWxlUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKShyb3V0ZVJlZ2V4KShuZXcgVVJMKHJld3JpdGVBcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyUm91dGVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgcm91dGVJbmZvIGJyaW5ncyBhIHJlZGlyZWN0IHdlIHNpbXBseSBhcHBseSBpdC5cbiAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnR5cGUgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCByb3V0ZUluZm8ubmV3VXJsLCByb3V0ZUluZm8ubmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogcm91dGVJbmZvLmRlc3RpbmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSByb3V0ZUluZm8uQ29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyaXB0cyA9IFtdLmNvbmNhdChjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKCkpO1xuICAgICAgICAgICAgICAgIHNjcmlwdHMuZm9yRWFjaCgoc2NyaXB0KT0+e1xuICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdC5oYW5kbGVDbGllbnRTY3JpcHRMb2FkKShzY3JpcHQucHJvcHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICBpZiAoKHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQKSAmJiByb3V0ZUluZm8ucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcyAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1Q7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1uYXZpZ2F0aW9uIGlmIGl0IGlzIGZhbGxpbmcgYmFjayB0byBoYXJkIG5hdmlnYXRpb24gaWZcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoXCIvXCIpICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUX0JBU0VfUEFUSCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEhyZWYgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB1cmw6IG5ld1VybCwgYXM6IG5ld0FzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgZGVzdGluYXRpb24sIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIFNTRyBkYXRhIDQwNFxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMubm90Rm91bmQgPT09IFNTR19EQVRBX05PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmRSb3V0ZSA9IFwiLzQwNFwiO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvX2Vycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWxsb3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIiAmJiAoKF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzLnBhZ2VQcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wcy5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm91dGVJbmZvX3JvdXRlO1xuICAgICAgICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlSW5mb19yb3V0ZSA9IHJvdXRlSW5mby5yb3V0ZSkgIT0gbnVsbCA/IF9yb3V0ZUluZm9fcm91dGUgOiByb3V0ZSk7XG4gICAgICAgICAgICB2YXIgX29wdGlvbnNfc2Nyb2xsO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gKF9vcHRpb25zX3Njcm9sbCA9IG9wdGlvbnMuc2Nyb2xsKSAhPSBudWxsID8gX29wdGlvbnNfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0U2Nyb2xsID0gc2hvdWxkU2Nyb2xsID8ge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1Njcm9sbFN0YXRlID0gZm9yY2VkU2Nyb2xsICE9IG51bGwgPyBmb3JjZWRTY3JvbGwgOiByZXNldFNjcm9sbDtcbiAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgY29uc3QgdXBjb21pbmdSb3V0ZXJTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXNQYXRoOiBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgICAgaXNGYWxsYmFjazogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBwYWdlIGJlaW5nIHJlbmRlcmVkIGlzIHRoZSA0MDQgcGFnZSwgd2Ugc2hvdWxkIG9ubHkgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgLy8gd2Fzbid0IG9yaWdpbmFsbHkgcHJlc2VudC4gVGhpcyBpcyBhbHNvIHdoeSB0aGlzIGJsb2NrIGlzIGJlZm9yZSB0aGVcbiAgICAgICAgICAgIC8vIGJlbG93IGBjaGFuZ2VTdGF0ZWAgY2FsbCB3aGljaCB1cGRhdGVzIHRoZSBicm93c2VyJ3MgaGlzdG9yeSAoY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc0Vycm9yUm91dGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLCBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSwgX3JvdXRlSW5mb19wcm9wczE7XG4gICAgICAgICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IHRoaXMucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2tcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gXCIgKyB0aGlzLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEgPSBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiAoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxID0gX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxLnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChfcm91dGVJbmZvX3Byb3BzMSA9IHJvdXRlSW5mby5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZUluZm9fcHJvcHMxLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIHN0YXR1c0NvZGUgaXMgc3RpbGwgY29ycmVjdCBmb3Igc3RhdGljIDUwMCBwYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldCh1cGNvbWluZ1JvdXRlclN0YXRlLCByb3V0ZUluZm8sIHVwY29taW5nU2Nyb2xsU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcImJlZm9yZUhpc3RvcnlDaGFuZ2VcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gZm9yIHF1ZXJ5IHVwZGF0ZXMgd2UgY2FuIHNraXAgaXQgaWYgdGhlIHN0YXRlIGlzIHVuY2hhbmdlZCBhbmQgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2Nyb2xsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICBjb25zdCBjYW5Ta2lwVXBkYXRpbmcgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXVwY29taW5nU2Nyb2xsU3RhdGUgJiYgIXJlYWR5U3RhdGVDaGFuZ2UgJiYgIWxvY2FsZUNoYW5nZSAmJiAoMCwgX2NvbXBhcmVzdGF0ZXMuY29tcGFyZVJvdXRlclN0YXRlcykodXBjb21pbmdSb3V0ZXJTdGF0ZSwgdGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxsZWQpIHJvdXRlSW5mby5lcnJvciA9IHJvdXRlSW5mby5lcnJvciB8fCBlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgcm91dGVJbmZvLmVycm9yLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHJvdXRlSW5mby5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgaGFzaFJlZ2V4LnRlc3QoYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9IYXNoKGFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeS5cIiArIG1ldGhvZCArIFwiIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgfHwgKDAsIF91dGlscy5nZXRVUkwpKCkgIT09IGFzKSB7XG4gICAgICAgICAgICB0aGlzLl9zaGFsbG93ID0gb3B0aW9ucy5zaGFsbG93O1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnlbbWV0aG9kXSh7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgX19OOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleTogdGhpcy5fa2V5ID0gbWV0aG9kICE9PSBcInB1c2hTdGF0ZVwiID8gdGhpcy5fa2V5IDogY3JlYXRlS2V5KClcbiAgICAgICAgICAgIH0sIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgICAgLy8gUGFzc2luZyB0aGUgZW1wdHkgc3RyaW5nIGhlcmUgc2hvdWxkIGJlIHNhZmUgYWdhaW5zdCBmdXR1cmUgY2hhbmdlcyB0byB0aGUgbWV0aG9kLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0hpc3RvcnkvcmVwbGFjZVN0YXRlXG4gICAgICAgICAgICBcIlwiLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxsYXRpb24gZXJyb3JzXG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgwLCBfcm91dGVsb2FkZXIuaXNBc3NldEVycm9yKShlcnIpIHx8IGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgZXJyLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcbiAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPSBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KFwiL19lcnJvclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6IFwiLCBnaXBFcnIpO1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5kZWZhdWx0KShyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArIFwiXCIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSb3V0ZUluZm8ocGFyYW0pIHtcbiAgICAgICAgbGV0IHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlLCBwYXRobmFtZSwgcXVlcnksIGFzLCByZXNvbHZlZEFzLCByb3V0ZVByb3BzLCBsb2NhbGUsIGhhc01pZGRsZXdhcmUsIGlzUHJldmlldywgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLCBpc1F1ZXJ5VXBkYXRpbmcsIGlzTWlkZGxld2FyZVJld3JpdGUsIGlzTm90Rm91bmQgfSA9IHBhcmFtO1xuICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9kYXRhX2VmZmVjdCwgX2RhdGFfZWZmZWN0MSwgX2RhdGFfZWZmZWN0MiwgX2RhdGFfcmVzcG9uc2U7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjYWNoZWRSb3V0ZUluZm8gPSBleGlzdGluZ0luZm8gJiYgIShcImluaXRpYWxcIiBpbiBleGlzdGluZ0luZm8pICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgPyBleGlzdGluZ0luZm8gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc0JhY2tncm91bmQgPSBpc1F1ZXJ5VXBkYXRpbmc7XG4gICAgICAgICAgICBjb25zdCBmZXRjaE5leHREYXRhUGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogaXNCYWNrZ3JvdW5kID8gdGhpcy5zYmMgOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICFpc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgIGlzQmFja2dyb3VuZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YShmZXRjaE5leHREYXRhUGFyYW1zKSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGlzTm90Rm91bmQgPyBcIi80MDRcIiA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIGZhbGxiYWNrIHJvdXRlIGFuZCB0aGUgcHJvcHMgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHdoZW4gcmVuZGVyaW5nIGVycm9yIHJvdXRlcyB3ZSBkb24ndCBhcHBseSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAvLyBlZmZlY3RzXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiAocGF0aG5hbWUgPT09IFwiL19lcnJvclwiIHx8IHBhdGhuYW1lID09PSBcIi80MDRcIikpIHtcbiAgICAgICAgICAgICAgICBkYXRhLmVmZmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdCA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfZWZmZWN0LnR5cGUpID09PSBcInJlZGlyZWN0LWludGVybmFsXCIgfHwgKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QxID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QxLnR5cGUpID09PSBcInJlZGlyZWN0LWV4dGVybmFsXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5lZmZlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChfZGF0YV9lZmZlY3QyID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QyLnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICAgICAgICAgIC8vIGR1cmluZyBxdWVyeSB1cGRhdGluZyB0aGUgcGFnZSBtdXN0IG1hdGNoIGFsdGhvdWdoIGR1cmluZ1xuICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgIC8vIGNhbiBiZSByZXR1cm5lZCBhbmQgdGhpcyBzaG91bGQgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIGlzIHZhbGlkIGZvciBpbmNyZW1lbnRhbCBtaWdyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSA9IHJlc29sdmVkUm91dGU7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGFnYWluIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgZGVzdGluYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXhpc3RpbmdJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBfaXNhcGlyb3V0ZS5pc0FQSVJvdXRlKShyb3V0ZSkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oKHJlcyk9Pih7XG4gICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRzOiByZXMuc3R5bGVTaGVldHMsXG4gICAgICAgICAgICAgICAgICAgIF9fTl9TU0c6IHJlcy5tb2QuX19OX1NTRyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0LWlzXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIicgKyBwYXRobmFtZSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhc0JhaWxlZFByZWZldGNoID0gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX3Jlc3BvbnNlID0gZGF0YS5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX3Jlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1taWRkbGV3YXJlLXNraXBcIik7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgIC8vIEZvciBub24tU1NHIHByZWZldGNoZXMgdGhhdCBiYWlsZWQgYmVmb3JlIHNlbmRpbmcgZGF0YVxuICAgICAgICAgICAgLy8gd2UgY2xlYXIgdGhlIGNhY2hlIHRvIGZldGNoIGZ1bGwgcmVzcG9uc2VcbiAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZGNbZGF0YS5kYXRhSHJlZl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3BzLCBjYWNoZUtleSB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pICYmICF3YXNCYWlsZWRQcmVmZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZGF0YS5qc29uXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFIcmVmID0gKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZGF0YUhyZWYpID8gZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMocm91dGVJbmZvLkNvbXBvbmVudCwgLy8gd2UgcHJvdmlkZSBBcHBUcmVlIGxhdGVyIHNvIHRoaXMgbmVlZHMgdG8gYmUgYGFueWBcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IGJ1c3QgdGhlIGRhdGEgY2FjaGUgZm9yIFNTUCByb3V0ZXMgYWx0aG91Z2hcbiAgICAgICAgICAgIC8vIG1pZGRsZXdhcmUgY2FuIHNraXAgY2FjaGUgcGVyIHJlcXVlc3Qgd2l0aFxuICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICBpZiAocm91dGVJbmZvLl9fTl9TU1AgJiYgZmV0Y2hOZXh0RGF0YVBhcmFtcy5kYXRhSHJlZiAmJiBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzUHJldmlldyAmJiByb3V0ZUluZm8uX19OX1NTRyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKE9iamVjdC5hc3NpZ24oe30sIGZldGNoTmV4dERhdGFQYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNiY1xuICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcHMucGFnZVByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMucGFnZVByb3BzKTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgcm91dGVJbmZvLnJvdXRlID0gcm91dGU7XG4gICAgICAgICAgICByb3V0ZUluZm8ucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSByb3V0ZUluZm87XG4gICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNlcnJvci5nZXRQcm9wZXJFcnJvcikoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHN0YXRlLCBkYXRhLCByZXNldFNjcm9sbCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXS5Db21wb25lbnQsIHJlc2V0U2Nyb2xsKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIENhbGxiYWNrIHRvIGV4ZWN1dGUgYmVmb3JlIHJlcGxhY2luZyByb3V0ZXIgc3RhdGVcbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAqLyBiZWZvcmVQb3BTdGF0ZShjYikge1xuICAgICAgICB0aGlzLl9icHMgPSBjYjtcbiAgICB9XG4gICAgb25seUFIYXNoQ2hhbmdlKGFzKSB7XG4gICAgICAgIGlmICghdGhpcy5hc1BhdGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdChcIiNcIiwgMik7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoXCIjXCIsIDIpO1xuICAgICAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgICAgIGlmIChuZXdIYXNoICYmIG9sZFVybE5vSGFzaCA9PT0gbmV3VXJsTm9IYXNoICYmIG9sZEhhc2ggPT09IG5ld0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICAgICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGhhc2ggaGFzIGNoYW5nZWQsIHRoZW4gaXQncyBhIGhhc2ggb25seSBjaGFuZ2UuXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAgICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAgICAgLy8gYW5kIGlzIHRyZWF0ZWQgYXMgYSBuZXh0IHJlbG9hZC5cbiAgICAgICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2g7XG4gICAgfVxuICAgIHNjcm9sbFRvSGFzaChhcykge1xuICAgICAgICBjb25zdCBbLCBoYXNoID0gXCJcIl0gPSBhcy5zcGxpdChcIiNcIiwgMik7XG4gICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICAgICAgaWYgKGhhc2ggPT09IFwiXCIgfHwgaGFzaCA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgICAgICBjb25zdCByYXdIYXNoID0gZGVjb2RlVVJJQ29tcG9uZW50KGhhc2gpO1xuICAgICAgICAgICAgLy8gRmlyc3Qgd2UgY2hlY2sgaWYgdGhlIGVsZW1lbnQgYnkgaWQgaXMgZm91bmRcbiAgICAgICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgICAgIGlmIChpZEVsKSB7XG4gICAgICAgICAgICAgICAgaWRFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgICAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb25seUhhc2hDaGFuZ2U6IHRoaXMub25seUFIYXNoQ2hhbmdlKGFzKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXJsSXNOZXcoYXNQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoO1xuICAgIH1cbiAgICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqLyBhc3luYyBwcmVmZXRjaCh1cmwsIGFzUGF0aCwgb3B0aW9ucykge1xuICAgICAgICBpZiAoYXNQYXRoID09PSB2b2lkIDApIGFzUGF0aCA9IHVybDtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoMCwgX2lzYm90LmlzQm90KSh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIC8vIE5vIHByZWZldGNoZXMgZm9yIGJvdHMgdGhhdCByZW5kZXIgdGhlIGxpbmsgc2luY2UgdGhleSBhcmUgdHlwaWNhbGx5IG5hdmlnYXRpbmdcbiAgICAgICAgICAgIC8vIGxpbmtzIHZpYSB0aGUgZXF1aXZhbGVudCBvZiBhIGhhcmQgbmF2aWdhdGlvbiBhbmQgaGVuY2UgbmV2ZXIgdXRpbGl6ZSB0aGVzZVxuICAgICAgICAgICAgLy8gcHJlZmV0Y2hlcy5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKHVybCk7XG4gICAgICAgIGNvbnN0IHVybFBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICBsZXQgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHBhcnNlZDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKHBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZWRBcyA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShhc1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGFyc2VkQXMucGF0aG5hbWUsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgYXNQYXRoID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSBcInVuZGVmaW5lZFwiID8gb3B0aW9ucy5sb2NhbGUgfHwgdW5kZWZpbmVkIDogdGhpcy5sb2NhbGU7XG4gICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXNQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAoeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9ID0gYXdhaXQgKDAsIF9yb3V0ZWxvYWRlci5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlcmV3cml0ZXMuZGVmYXVsdCkoKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhc1BhdGgsIHRoaXMubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkLnF1ZXJ5LCAocCk9PnJlc29sdmVEeW5hbWljUm91dGUocCwgcGFnZXMpLCB0aGlzLmxvY2FsZXMpO1xuICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmVsb2NhbGUucmVtb3ZlTG9jYWxlKSgoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLCB0aGlzLmxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSBcInN0cmljdFwiID8gbnVsbCA6IGF3YWl0IHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBvcmlnaW5hbFBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFyYW1ldGVycyBmb3IgdGhlIHByZWZldGNoLlxuICAgICAqLyBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuZWZmZWN0LnR5cGUpID09PSBcInJld3JpdGVcIikge1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICBxdWVyeSA9IHtcbiAgICAgICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZWRpcmVjdC1leHRlcm5hbFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBpZiAoYXdhaXQgdGhpcy5fYmZsKGFzUGF0aCwgcmVzb2x2ZWRBcywgb3B0aW9ucy5sb2NhbGUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbdXJsUGF0aG5hbWVdID0ge1xuICAgICAgICAgICAgICAgIF9fYXBwUm91dGVyOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5faXNTc2cocm91dGUpLnRoZW4oKGlzU3NnKT0+e1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgPyBkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIXRoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8IG9wdGlvbnMucHJpb3JpdHkgJiYgISFwcm9jZXNzLmVudi5fX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEVcbiAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkuY2F0Y2goKCk9PmZhbHNlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/IFwibG9hZFBhZ2VcIiA6IFwicHJlZmV0Y2hcIl0ocm91dGUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmxvYWRQYWdlKHJvdXRlKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZ2V0RGF0YShmbikge1xuICAgICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpPT57XG4gICAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsYyA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIGZuKCkudGhlbigoZGF0YSk9PntcbiAgICAgICAgICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIkxvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgICAgICAgZXJyLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmxpZ2h0RGF0YShkYXRhSHJlZikge1xuICAgICAgICAvLyBEbyBub3QgY2FjaGUgUlNDIGZsaWdodCByZXNwb25zZSBzaW5jZSBpdCdzIG5vdCBhIHN0YXRpYyByZXNvdXJjZVxuICAgICAgICByZXR1cm4gZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFyc2VKU09OOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlXG4gICAgICAgIH0pLnRoZW4oKHBhcmFtKT0+e1xuICAgICAgICAgICAgbGV0IHsgdGV4dCB9ID0gcGFyYW07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IHRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQ6IEFwcCB9ID0gdGhpcy5jb21wb25lbnRzW1wiL19hcHBcIl07XG4gICAgICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCk7XG4gICAgICAgIGN0eC5BcHBUcmVlID0gQXBwVHJlZTtcbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbHMubG9hZEdldEluaXRpYWxQcm9wcykoQXBwLCB7XG4gICAgICAgICAgICBBcHBUcmVlLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgY3R4XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgcm91dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnJvdXRlO1xuICAgIH1cbiAgICBnZXQgcGF0aG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBhdGhuYW1lO1xuICAgIH1cbiAgICBnZXQgcXVlcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXJ5O1xuICAgIH1cbiAgICBnZXQgYXNQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGg7XG4gICAgfVxuICAgIGdldCBsb2NhbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmxvY2FsZTtcbiAgICB9XG4gICAgZ2V0IGlzRmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2s7XG4gICAgfVxuICAgIGdldCBpc1ByZXZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzUHJldmlldztcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGF0aG5hbWUsIHF1ZXJ5LCBhcywgeyBpbml0aWFsUHJvcHMsIHBhZ2VMb2FkZXIsIEFwcCwgd3JhcEFwcCwgQ29tcG9uZW50LCBlcnIsIHN1YnNjcmlwdGlvbiwgaXNGYWxsYmFjaywgbG9jYWxlLCBsb2NhbGVzLCBkZWZhdWx0TG9jYWxlLCBkb21haW5Mb2NhbGVzLCBpc1ByZXZpZXcgfSl7XG4gICAgICAgIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2RjID0ge307XG4gICAgICAgIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNiYyA9IHt9O1xuICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fa2V5ID0gY3JlYXRlS2V5KCk7XG4gICAgICAgIHRoaXMub25Qb3BTdGF0ZSA9IChlKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpc0ZpcnN0UG9wU3RhdGVFdmVudCB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzLmdldFVSTCkoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgcG9wc3RhdGVldmVudCB3aGVuIHJlb3BlbmluZyB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0UG9wU3RhdGVFdmVudCAmJiB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiYgc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucywga2V5IH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9rZXkgIT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHNlbGYucGFnZVlPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSBvbGQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcIl9fbmV4dF9zY3JvbGxfXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2Uodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VkU2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKSh1cmwpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgICAgICAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3NyICYmIGFzID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLmFzUGF0aCkgJiYgcGF0aG5hbWUgPT09ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHRoaXMucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGRvd25zdHJlYW0gYXBwbGljYXRpb24gcmV0dXJucyBmYWxzeSwgcmV0dXJuLlxuICAgICAgICAgICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9icHMgJiYgIXRoaXMuX2JwcyhzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoYW5nZShcInJlcGxhY2VTdGF0ZVwiLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xuICAgICAgICAgICAgICAgIF9oOiAwXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICAgICAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhpcyBjYXVzZSBpc3N1ZXMgd2hlbiB3aGVuIGdvaW5nIGJhY2sgYW5kXG4gICAgICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICAgICAgaWYgKHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiBBcHAsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEKSB7XG4gICAgICAgICAgICBjb25zdCB7IEJsb29tRmlsdGVyIH0gPSByZXF1aXJlKFwiLi4vLi4vbGliL2Jsb29tLWZpbHRlclwiKTtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlckZpbHRlclNWYWx1ZSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGljRmlsdGVyRGF0YSA9IHJvdXRlckZpbHRlclNWYWx1ZSA/IHJvdXRlckZpbHRlclNWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlckZpbHRlckRWYWx1ZSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgY29uc3QgZHluYW1pY0ZpbHRlckRhdGEgPSByb3V0ZXJGaWx0ZXJEVmFsdWUgPyByb3V0ZXJGaWx0ZXJEVmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3RhdGljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihzdGF0aWNGaWx0ZXJEYXRhLm51bUl0ZW1zLCBzdGF0aWNGaWx0ZXJEYXRhLmVycm9yUmF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGR5bmFtaWNGaWx0ZXJEYXRhID09IG51bGwgPyB2b2lkIDAgOiBkeW5hbWljRmlsdGVyRGF0YS5udW1IYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZCA9IG5ldyBCbG9vbUZpbHRlcihkeW5hbWljRmlsdGVyRGF0YS5udW1JdGVtcywgZHluYW1pY0ZpbHRlckRhdGEuZXJyb3JSYXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfZC5pbXBvcnQoZHluYW1pY0ZpbHRlckRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXQgZm9yIFJvdXRlci5yb3V0ZXIuZXZlbnRzXG4gICAgICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgICAgIHRoaXMuZXZlbnRzID0gUm91dGVyLmV2ZW50cztcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyID0gcGFnZUxvYWRlcjtcbiAgICAgICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAgICAgLy8gdW50aWwgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgICAgICAgY29uc3QgYXV0b0V4cG9ydER5bmFtaWMgPSAoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocGF0aG5hbWUpICYmIHNlbGYuX19ORVhUX0RBVEFfXy5hdXRvRXhwb3J0O1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gcHJvY2Vzcy5lbnYuX19ORVhUX1JPVVRFUl9CQVNFUEFUSCB8fCBcIlwiO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5pc0V4cGVyaW1lbnRhbENvbXBpbGUgfHwgc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCB8fCAhYXV0b0V4cG9ydER5bmFtaWMgJiYgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlO1xuICAgICAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzID0gZG9tYWluTG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSAhISgwLCBfZGV0ZWN0ZG9tYWlubG9jYWxlLmRldGVjdERvbWFpbkxvY2FsZSkoZG9tYWluTG9jYWxlcywgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGFzUGF0aDogYXV0b0V4cG9ydER5bmFtaWMgPyBwYXRobmFtZSA6IGFzLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiAhIWlzUHJldmlldyxcbiAgICAgICAgICAgIGxvY2FsZTogcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCA/IGxvY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGlzRmFsbGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgICAgICAgIGlmICghYXMuc3RhcnRzV2l0aChcIi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gb3JkZXIgZm9yIGBlLnN0YXRlYCB0byB3b3JrIG9uIHRoZSBgb25wb3BzdGF0ZWAgZXZlbnRcbiAgICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzUGF0aCA9ICgwLCBfdXRpbHMuZ2V0VVJMKSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGhcbiAgICAgICAgICAgICAgICB9KS50aGVuKChtYXRjaGVzKT0+e1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcInJlcGxhY2VTdGF0ZVwiLCBtYXRjaGVzID8gYXNQYXRoIDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICB9KSwgYXNQYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvcHN0YXRlXCIsIHRoaXMub25Qb3BTdGF0ZSk7XG4gICAgICAgICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dC5kZWZhdWx0KSgpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiY3JlYXRlS2V5IiwiZGVmYXVsdCIsIm1hdGNoZXNNaWRkbGV3YXJlIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVtb3ZldHJhaWxpbmdzbGFzaCIsIl9yb3V0ZWxvYWRlciIsIl9zY3JpcHQiLCJfaXNlcnJvciIsIl8iLCJfZGVub3JtYWxpemVwYWdlcGF0aCIsIl9ub3JtYWxpemVsb2NhbGVwYXRoIiwiX21pdHQiLCJfdXRpbHMiLCJfaXNkeW5hbWljIiwiX3BhcnNlcmVsYXRpdmV1cmwiLCJfcmVzb2x2ZXJld3JpdGVzIiwiX3JvdXRlbWF0Y2hlciIsIl9yb3V0ZXJlZ2V4IiwiX2Zvcm1hdHVybCIsIl9kZXRlY3Rkb21haW5sb2NhbGUiLCJfcGFyc2VwYXRoIiwiX2FkZGxvY2FsZSIsIl9yZW1vdmVsb2NhbGUiLCJfcmVtb3ZlYmFzZXBhdGgiLCJfYWRkYmFzZXBhdGgiLCJfaGFzYmFzZXBhdGgiLCJfcmVzb2x2ZWhyZWYiLCJfaXNhcGlyb3V0ZSIsIl9nZXRuZXh0cGF0aG5hbWVpbmZvIiwiX2Zvcm1hdG5leHRwYXRobmFtZWluZm8iLCJfY29tcGFyZXN0YXRlcyIsIl9pc2xvY2FsdXJsIiwiX2lzYm90IiwiX29taXQiLCJfaW50ZXJwb2xhdGVhcyIsIl9oYW5kbGVzbW9vdGhzY3JvbGwiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwibWF0Y2hlcnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJvdXRlciIsInBhZ2VMb2FkZXIiLCJnZXRNaWRkbGV3YXJlIiwicGF0aG5hbWUiLCJhc1BhdGhuYW1lIiwicGFyc2VQYXRoIiwiYXNQYXRoIiwiY2xlYW5lZEFzIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJzb21lIiwibSIsIlJlZ0V4cCIsInJlZ2V4cCIsInRlc3QiLCJzdHJpcE9yaWdpbiIsInVybCIsIm9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsInJlc29sdmVIcmVmIiwiaHJlZldhc0Fic29sdXRlIiwiYXNXYXNBYnNvbHV0ZSIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZGVub3JtYWxpemVQYWdlUGF0aCIsImluY2x1ZGVzIiwicGFnZSIsImlzRHluYW1pY1JvdXRlIiwiZ2V0Um91dGVSZWdleCIsInJlIiwiZ2V0TWlkZGxld2FyZURhdGEiLCJzb3VyY2UiLCJyZXNwb25zZSIsIm5leHRDb25maWciLCJiYXNlUGF0aCIsImkxOG4iLCJsb2NhbGVzIiwidHJhaWxpbmdTbGFzaCIsIkJvb2xlYW4iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1RSQUlMSU5HX1NMQVNIIiwicmV3cml0ZUhlYWRlciIsImhlYWRlcnMiLCJyZXdyaXRlVGFyZ2V0IiwibWF0Y2hlZFBhdGgiLCJfX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUiLCJwYXJzZWRSZXdyaXRlVGFyZ2V0IiwicGFyc2VSZWxhdGl2ZVVybCIsInBhdGhuYW1lSW5mbyIsImdldE5leHRQYXRobmFtZUluZm8iLCJwYXJzZURhdGEiLCJmc1BhdGhuYW1lIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwidGhlbiIsInBhcmFtIiwiX19yZXdyaXRlcyIsInJld3JpdGVzIiwibm9ybWFsaXplTG9jYWxlUGF0aCIsInBhcnNlZFNvdXJjZSIsIl9fTkVYVF9IQVNfUkVXUklURVMiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImZldGNoRGF0YSIsImRhdGEiLCJlZmZlY3QiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiaHJlZiIsIlVSTCIsImxvY2F0aW9uIiwiZ2V0RGF0YSIsInBhcmFtcyIsIl9wYXJhbXNfbWV0aG9kIiwicHVycG9zZSIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsIk5PREVfRU5WIiwiY2F0Y2giLCJlcnIiLCJtZXNzYWdlIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJoYW5kbGVIYXJkTmF2aWdhdGlvbiIsImdldENhbmNlbGxlZEhhbmRsZXIiLCJyb3V0ZSIsImNhbmNlbCIsImNsYyIsImhhbmRsZUNhbmNlbGxlZCIsInJlbG9hZCIsImJhY2siLCJmb3J3YXJkIiwicHVzaCIsIl9rZXkiLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZSIsImNoYW5nZSIsInJlcGxhY2UiLCJfYmZsIiwic2tpcE5hdmlnYXRlIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsIl90aGlzX19iZmxfczEiLCJfYmZsX3MiLCJjb250YWlucyIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJzcGxpdCIsImkiLCJfdGhpc19fYmZsX2QiLCJjdXJyZW50UGFydCIsImpvaW4iLCJfYmZsX2QiLCJmb3JjZWRTY3JvbGwiLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiaXNMb2NhbFVSTCIsImlzUXVlcnlVcGRhdGluZyIsIl9oIiwic2hhbGxvdyIsInNob3VsZFJlc29sdmVIcmVmIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwibmV4dFN0YXRlIiwic3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwiaXNSZWFkeSIsImlzU3NyIiwicHJldkxvY2FsZSIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJsb2NhbGVQYXRoUmVzdWx0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsImRpZE5hdmlnYXRlIiwiX3RoaXNfbG9jYWxlcyIsImRldGVjdGVkRG9tYWluIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiZG9tYWluTG9jYWxlcyIsImlzTG9jYWxlRG9tYWluIiwiaG9zdG5hbWUiLCJkb21haW4iLCJhc05vQmFzZVBhdGgiLCJodHRwIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJzY3JvbGwiLCJyb3V0ZVByb3BzIiwiX2luRmxpZ2h0Um91dGUiLCJldmVudHMiLCJlbWl0IiwicmVtb3ZlTG9jYWxlIiwibG9jYWxlQ2hhbmdlIiwib25seUFIYXNoQ2hhbmdlIiwiY2hhbmdlU3RhdGUiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJjb21wb25lbnRzIiwicGFyc2VkIiwidXJsSXNOZXciLCJwYXJzZWRBc1BhdGhuYW1lIiwiX19hcHBSb3V0ZXIiLCJpc01pZGRsZXdhcmVSZXdyaXRlIiwiaXNNaWRkbGV3YXJlTWF0Y2giLCJyZXdyaXRlc1Jlc3VsdCIsInAiLCJleHRlcm5hbERlc3QiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJpbnRlcnBvbGF0ZUFzIiwibWlzc2luZ1BhcmFtcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImlzRXJyb3JSb3V0ZSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyIsIl9yb3V0ZUluZm9fcHJvcHMiLCJyb3V0ZUluZm8iLCJnZXRSb3V0ZUluZm8iLCJpc1ByZXZpZXciLCJpc0ZhbGxiYWNrIiwiY2xlYW5lZFBhcnNlZFBhdGhuYW1lIiwiZm9yRWFjaCIsImtleSIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50IiwiQ29tcG9uZW50IiwidW5zdGFibGVfc2NyaXB0TG9hZGVyIiwic2NyaXB0cyIsImNvbmNhdCIsInNjcmlwdCIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJwcm9wcyIsIl9fTl9TU0ciLCJfX05fU1NQIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsInBhcnNlZEhyZWYiLCJfX05fUFJFVklFVyIsIm5vdEZvdW5kUm91dGUiLCJmZXRjaENvbXBvbmVudCIsImlzTm90Rm91bmQiLCJfX05FWFRfREFUQV9fIiwic3RhdHVzQ29kZSIsIl9yb3V0ZUluZm9fcm91dGUiLCJpc1ZhbGlkU2hhbGxvd1JvdXRlIiwiX29wdGlvbnNfc2Nyb2xsIiwic2hvdWxkU2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1Njcm9sbFN0YXRlIiwidXBjb21pbmdSb3V0ZXJTdGF0ZSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHNfcGFnZVByb3BzMSIsIl9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxIiwiX3JvdXRlSW5mb19wcm9wczEiLCJjYW5Ta2lwVXBkYXRpbmciLCJjb21wYXJlUm91dGVyU3RhdGVzIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5nIiwiaGFzaFJlZ2V4IiwiZ2V0VVJMIiwiX3NoYWxsb3ciLCJfX04iLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJpc0Fzc2V0RXJyb3IiLCJzdHlsZVNoZWV0cyIsImdldEluaXRpYWxQcm9wcyIsImdpcEVyciIsInJvdXRlSW5mb0VyciIsInJlcXVlc3RlZFJvdXRlIiwiX2RhdGFfZWZmZWN0IiwiX2RhdGFfZWZmZWN0MSIsIl9kYXRhX2VmZmVjdDIiLCJfZGF0YV9yZXNwb25zZSIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwic2JjIiwic2RjIiwicmVzb2x2ZWRSb3V0ZSIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ3YXNCYWlsZWRQcmVmZXRjaCIsInNob3VsZEZldGNoRGF0YSIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwic3ViIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIl9icHMiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvbmx5SGFzaENoYW5nZSIsInByZWZldGNoIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXRobmFtZSIsIm9yaWdpbmFsUGF0aG5hbWUiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiX2dldEZsaWdodERhdGEiLCJjdHgiLCJBcHAiLCJBcHBUcmVlIiwiX3dyYXBBcHAiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiY29uc3RydWN0b3IiLCJpbml0aWFsUHJvcHMiLCJ3cmFwQXBwIiwic3Vic2NyaXB0aW9uIiwiaXNGaXJzdFBvcFN0YXRlRXZlbnQiLCJvblBvcFN0YXRlIiwiX19OQSIsImdldEl0ZW0iLCJpbml0aWFsIiwiQmxvb21GaWx0ZXIiLCJyb3V0ZXJGaWx0ZXJTVmFsdWUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUiIsInN0YXRpY0ZpbHRlckRhdGEiLCJyb3V0ZXJGaWx0ZXJEVmFsdWUiLCJfX05FWFRfQ0xJRU5UX1JPVVRFUl9EX0ZJTFRFUiIsImR5bmFtaWNGaWx0ZXJEYXRhIiwibnVtSGFzaGVzIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJpbXBvcnQiLCJhdXRvRXhwb3J0RHluYW1pYyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwiZ3NzcCIsImdpcCIsImlzRXhwZXJpbWVudGFsQ29tcGlsZSIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});